[[insns-vclmul-32e, Vector Carry-less Multiply]]
= vclmul.[vv,vx]

Synopsis::
Vector Carry-less Multiply by vector or scalar - returning low half of product.

Mnemonic::
vclmul.vv vd, vs2, vs1, vm +
vclmul.vx vd, vs2, rs1, vm

Encoding (Vector-Vector)::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPMVV'},
{bits: 5, name: 'vs1'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm'},
{bits: 6, name: '001100'},
]}
....

Encoding (Vector-Scalar)::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPMVX'},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'vs2'},
{bits: 1, name: 'vm'},
{bits: 6, name: '001100'},
]}
....
Reserved Encodings::
* `SEW` is any value other than 32 (`Zvbc32e` only)
* `SEW` is any value other than 64 (`Zvbc` only)
* `SEW` is any value other than 32 or 64 (`Zvbc` and `Zvbc32e`)

Arguments::

[%autowidth]
[%header,cols="4,2,2"]
|===
|Register
|Direction
|Definition

| `vs1`/`rs1` | input  | multiplier
| `vs2`       | input  | multiplicand
| `vd`        | output | lower part of carry-less multiply 
|===

[NOTE]
====
`vclmul` instruction was initially defined in `Zvbc` with only `SEW=64-bit` support, this page describes how the specification is extended in `Zvbc32e` to support `SEW=32` bits.
====

Description::
Produces the low half of `2*SEW`-bit carry-less product.

Each SEW-bit element in the `vs2` vector register is carry-less multiplied by
either each SEW-bit element in `vs1` (vector-vector), or the SEW-bit value
from integer register `rs1` (vector-scalar). The result is the least
significant SEW bits of the carry-less product.

[NOTE]
====
The 32-bit carryless multiply instructions can be used for implementing GCM in the absence of the `zvkg` extension.
In particular for implementation with `ELEN=32` where `Zvkg` cannot be implemented. 
It can also be used to speed-up CRC evaluation.
====

Operation::
[source,sail]
--


function clause execute (VCLMUL(vs2, vs1, vd, suffix)) = {

  foreach (i from vstart to vl-1) {
    let op1 : bits (SEW) = if suffix =="vv" then get_velem(vs1, i)
                          else zext_or_truncate_to_sew(X(vs1));
    let op2 : bits (SEW) = get_velem(vs2, i);
    let product : bits (SEW) = clmul(op1, op2, SEW);
    set_velem(vd, i, product);
  }
  RETIRE_SUCCESS
}

function clmul(x, y, width) = {
  let result : bits(width) = zeros();
  foreach (i from 0 to (width - 1)) {
    if y[i] == 1 then result = result ^ (x << i);
  }
  result
}
--

Included in::
<<zvbc32e>>
